// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: timetable/v1/type.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public enum Timetable_V1_Module: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case springA // = 1
    case springB // = 2
    case springC // = 3
    case fallA // = 4
    case fallB // = 5
    case fallC // = 6
    case summerVacation // = 7
    case springVacation // = 8
    case UNRECOGNIZED(Int)

    public init() {
        self = .unspecified
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .springA
        case 2: self = .springB
        case 3: self = .springC
        case 4: self = .fallA
        case 5: self = .fallB
        case 6: self = .fallC
        case 7: self = .summerVacation
        case 8: self = .springVacation
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .springA: return 1
        case .springB: return 2
        case .springC: return 3
        case .fallA: return 4
        case .fallB: return 5
        case .fallC: return 6
        case .summerVacation: return 7
        case .springVacation: return 8
        case let .UNRECOGNIZED(i): return i
        }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Timetable_V1_Module] = [
        .unspecified,
        .springA,
        .springB,
        .springC,
        .fallA,
        .fallB,
        .fallC,
        .summerVacation,
        .springVacation,
    ]
}

public enum Timetable_V1_Day: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case sun // = 1
    case mon // = 2
    case tue // = 3
    case wed // = 4
    case thu // = 5
    case fri // = 6
    case sat // = 7
    case intensive // = 8
    case appointment // = 9
    case anyTime // = 10
    case nt // = 11
    case UNRECOGNIZED(Int)

    public init() {
        self = .unspecified
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .sun
        case 2: self = .mon
        case 3: self = .tue
        case 4: self = .wed
        case 5: self = .thu
        case 6: self = .fri
        case 7: self = .sat
        case 8: self = .intensive
        case 9: self = .appointment
        case 10: self = .anyTime
        case 11: self = .nt
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .sun: return 1
        case .mon: return 2
        case .tue: return 3
        case .wed: return 4
        case .thu: return 5
        case .fri: return 6
        case .sat: return 7
        case .intensive: return 8
        case .appointment: return 9
        case .anyTime: return 10
        case .nt: return 11
        case let .UNRECOGNIZED(i): return i
        }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Timetable_V1_Day] = [
        .unspecified,
        .sun,
        .mon,
        .tue,
        .wed,
        .thu,
        .fri,
        .sat,
        .intensive,
        .appointment,
        .anyTime,
        .nt,
    ]
}

public enum Timetable_V1_CourseMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case onlineAsynchronous // = 1
    case onlineSynchronous // = 2
    case faceToFace // = 3
    case others // = 4
    case UNRECOGNIZED(Int)

    public init() {
        self = .unspecified
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .onlineAsynchronous
        case 2: self = .onlineSynchronous
        case 3: self = .faceToFace
        case 4: self = .others
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .onlineAsynchronous: return 1
        case .onlineSynchronous: return 2
        case .faceToFace: return 3
        case .others: return 4
        case let .UNRECOGNIZED(i): return i
        }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Timetable_V1_CourseMethod] = [
        .unspecified,
        .onlineAsynchronous,
        .onlineSynchronous,
        .faceToFace,
        .others,
    ]
}

public struct Timetable_V1_Schedule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var module: Timetable_V1_Module = .unspecified

    public var day: Timetable_V1_Day = .unspecified

    public var period: Int32 = 0

    public var locations: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_CourseMethodList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Timetable_V1_CourseMethod] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_ScheduleList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var values: [Timetable_V1_Schedule] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_Course: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Shared_UUID {
        get { return _id ?? Shared_UUID() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool { return self._id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() { self._id = nil }

    public var year: Shared_AcademicYear {
        get { return _year ?? Shared_AcademicYear() }
        set { _year = newValue }
    }

    /// Returns true if `year` has been explicitly set.
    public var hasYear: Bool { return self._year != nil }
    /// Clears the value of `year`. Subsequent reads from it will return its default value.
    public mutating func clearYear() { self._year = nil }

    public var code: String = String()

    public var name: String = String()

    public var instructors: String = String()

    public var credit: String = String()

    public var overview: String = String()

    public var remarks: String = String()

    public var lastUpdatedAt: Shared_RFC3339DateTime {
        get { return _lastUpdatedAt ?? Shared_RFC3339DateTime() }
        set { _lastUpdatedAt = newValue }
    }

    /// Returns true if `lastUpdatedAt` has been explicitly set.
    public var hasLastUpdatedAt: Bool { return self._lastUpdatedAt != nil }
    /// Clears the value of `lastUpdatedAt`. Subsequent reads from it will return its default value.
    public mutating func clearLastUpdatedAt() { self._lastUpdatedAt = nil }

    public var recommendedGrades: [Int32] = []

    public var methods: [Timetable_V1_CourseMethod] = []

    public var schedules: [Timetable_V1_Schedule] = []

    public var hasParseError_p: Bool = false

    public var isAnnual: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Shared_UUID? = nil
    fileprivate var _year: Shared_AcademicYear? = nil
    fileprivate var _lastUpdatedAt: Shared_RFC3339DateTime? = nil
}

/// If it has the based course, code is present.
public struct Timetable_V1_RegisteredCourse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Shared_UUID {
        get { return _id ?? Shared_UUID() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool { return self._id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() { self._id = nil }

    public var userID: Shared_UUID {
        get { return _userID ?? Shared_UUID() }
        set { _userID = newValue }
    }

    /// Returns true if `userID` has been explicitly set.
    public var hasUserID: Bool { return self._userID != nil }
    /// Clears the value of `userID`. Subsequent reads from it will return its default value.
    public mutating func clearUserID() { self._userID = nil }

    public var year: Shared_AcademicYear {
        get { return _year ?? Shared_AcademicYear() }
        set { _year = newValue }
    }

    /// Returns true if `year` has been explicitly set.
    public var hasYear: Bool { return self._year != nil }
    /// Clears the value of `year`. Subsequent reads from it will return its default value.
    public mutating func clearYear() { self._year = nil }

    public var code: String {
        get { return _code ?? String() }
        set { _code = newValue }
    }

    /// Returns true if `code` has been explicitly set.
    public var hasCode: Bool { return self._code != nil }
    /// Clears the value of `code`. Subsequent reads from it will return its default value.
    public mutating func clearCode() { self._code = nil }

    public var name: String = String()

    public var instructors: String = String()

    public var credit: String = String()

    public var methods: [Timetable_V1_CourseMethod] = []

    public var schedules: [Timetable_V1_Schedule] = []

    public var memo: String = String()

    public var attendance: Int32 = 0

    public var absence: Int32 = 0

    public var late: Int32 = 0

    public var tagIds: [Shared_UUID] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Shared_UUID? = nil
    fileprivate var _userID: Shared_UUID? = nil
    fileprivate var _year: Shared_AcademicYear? = nil
    fileprivate var _code: String? = nil
}

public struct Timetable_V1_Tag: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Shared_UUID {
        get { return _id ?? Shared_UUID() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool { return self._id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() { self._id = nil }

    public var userID: Shared_UUID {
        get { return _userID ?? Shared_UUID() }
        set { _userID = newValue }
    }

    /// Returns true if `userID` has been explicitly set.
    public var hasUserID: Bool { return self._userID != nil }
    /// Clears the value of `userID`. Subsequent reads from it will return its default value.
    public mutating func clearUserID() { self._userID = nil }

    public var name: String = String()

    public var order: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Shared_UUID? = nil
    fileprivate var _userID: Shared_UUID? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "timetable.v1"

extension Timetable_V1_Module: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "MODULE_UNSPECIFIED"),
        1: .same(proto: "MODULE_SPRING_A"),
        2: .same(proto: "MODULE_SPRING_B"),
        3: .same(proto: "MODULE_SPRING_C"),
        4: .same(proto: "MODULE_FALL_A"),
        5: .same(proto: "MODULE_FALL_B"),
        6: .same(proto: "MODULE_FALL_C"),
        7: .same(proto: "MODULE_SUMMER_VACATION"),
        8: .same(proto: "MODULE_SPRING_VACATION"),
    ]
}

extension Timetable_V1_Day: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "DAY_UNSPECIFIED"),
        1: .same(proto: "DAY_SUN"),
        2: .same(proto: "DAY_MON"),
        3: .same(proto: "DAY_TUE"),
        4: .same(proto: "DAY_WED"),
        5: .same(proto: "DAY_THU"),
        6: .same(proto: "DAY_FRI"),
        7: .same(proto: "DAY_SAT"),
        8: .same(proto: "DAY_INTENSIVE"),
        9: .same(proto: "DAY_APPOINTMENT"),
        10: .same(proto: "DAY_ANY_TIME"),
        11: .same(proto: "DAY_NT"),
    ]
}

extension Timetable_V1_CourseMethod: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "COURSE_METHOD_UNSPECIFIED"),
        1: .same(proto: "COURSE_METHOD_ONLINE_ASYNCHRONOUS"),
        2: .same(proto: "COURSE_METHOD_ONLINE_SYNCHRONOUS"),
        3: .same(proto: "COURSE_METHOD_FACE_TO_FACE"),
        4: .same(proto: "COURSE_METHOD_OTHERS"),
    ]
}

extension Timetable_V1_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Schedule"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "module"),
        2: .same(proto: "day"),
        3: .same(proto: "period"),
        4: .same(proto: "locations"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &self.module)
            case 2: try decoder.decodeSingularEnumField(value: &self.day)
            case 3: try decoder.decodeSingularInt32Field(value: &self.period)
            case 4: try decoder.decodeSingularStringField(value: &self.locations)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.module != .unspecified {
            try visitor.visitSingularEnumField(value: self.module, fieldNumber: 1)
        }
        if self.day != .unspecified {
            try visitor.visitSingularEnumField(value: self.day, fieldNumber: 2)
        }
        if self.period != 0 {
            try visitor.visitSingularInt32Field(value: self.period, fieldNumber: 3)
        }
        if !self.locations.isEmpty {
            try visitor.visitSingularStringField(value: self.locations, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_Schedule, rhs: Timetable_V1_Schedule) -> Bool {
        if lhs.module != rhs.module { return false }
        if lhs.day != rhs.day { return false }
        if lhs.period != rhs.period { return false }
        if lhs.locations != rhs.locations { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_CourseMethodList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CourseMethodList"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "values"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedEnumField(value: &self.values)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.values.isEmpty {
            try visitor.visitPackedEnumField(value: self.values, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_CourseMethodList, rhs: Timetable_V1_CourseMethodList) -> Bool {
        if lhs.values != rhs.values { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_ScheduleList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ScheduleList"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "values"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &self.values)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.values.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_ScheduleList, rhs: Timetable_V1_ScheduleList) -> Bool {
        if lhs.values != rhs.values { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_Course: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Course"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "year"),
        3: .same(proto: "code"),
        4: .same(proto: "name"),
        5: .same(proto: "instructors"),
        6: .same(proto: "credit"),
        7: .same(proto: "overview"),
        8: .same(proto: "remarks"),
        9: .standard(proto: "last_updated_at"),
        10: .standard(proto: "recommended_grades"),
        11: .same(proto: "methods"),
        12: .same(proto: "schedules"),
        13: .standard(proto: "has_parse_error"),
        14: .standard(proto: "is_annual"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._id)
            case 2: try decoder.decodeSingularMessageField(value: &self._year)
            case 3: try decoder.decodeSingularStringField(value: &self.code)
            case 4: try decoder.decodeSingularStringField(value: &self.name)
            case 5: try decoder.decodeSingularStringField(value: &self.instructors)
            case 6: try decoder.decodeSingularStringField(value: &self.credit)
            case 7: try decoder.decodeSingularStringField(value: &self.overview)
            case 8: try decoder.decodeSingularStringField(value: &self.remarks)
            case 9: try decoder.decodeSingularMessageField(value: &self._lastUpdatedAt)
            case 10: try decoder.decodeRepeatedInt32Field(value: &self.recommendedGrades)
            case 11: try decoder.decodeRepeatedEnumField(value: &self.methods)
            case 12: try decoder.decodeRepeatedMessageField(value: &self.schedules)
            case 13: try decoder.decodeSingularBoolField(value: &self.hasParseError_p)
            case 14: try decoder.decodeSingularBoolField(value: &self.isAnnual)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._year {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !self.code.isEmpty {
            try visitor.visitSingularStringField(value: self.code, fieldNumber: 3)
        }
        if !self.name.isEmpty {
            try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
        }
        if !self.instructors.isEmpty {
            try visitor.visitSingularStringField(value: self.instructors, fieldNumber: 5)
        }
        if !self.credit.isEmpty {
            try visitor.visitSingularStringField(value: self.credit, fieldNumber: 6)
        }
        if !self.overview.isEmpty {
            try visitor.visitSingularStringField(value: self.overview, fieldNumber: 7)
        }
        if !self.remarks.isEmpty {
            try visitor.visitSingularStringField(value: self.remarks, fieldNumber: 8)
        }
        try { if let v = self._lastUpdatedAt {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
        } }()
        if !self.recommendedGrades.isEmpty {
            try visitor.visitPackedInt32Field(value: self.recommendedGrades, fieldNumber: 10)
        }
        if !self.methods.isEmpty {
            try visitor.visitPackedEnumField(value: self.methods, fieldNumber: 11)
        }
        if !self.schedules.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.schedules, fieldNumber: 12)
        }
        if self.hasParseError_p != false {
            try visitor.visitSingularBoolField(value: self.hasParseError_p, fieldNumber: 13)
        }
        if self.isAnnual != false {
            try visitor.visitSingularBoolField(value: self.isAnnual, fieldNumber: 14)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_Course, rhs: Timetable_V1_Course) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._year != rhs._year { return false }
        if lhs.code != rhs.code { return false }
        if lhs.name != rhs.name { return false }
        if lhs.instructors != rhs.instructors { return false }
        if lhs.credit != rhs.credit { return false }
        if lhs.overview != rhs.overview { return false }
        if lhs.remarks != rhs.remarks { return false }
        if lhs._lastUpdatedAt != rhs._lastUpdatedAt { return false }
        if lhs.recommendedGrades != rhs.recommendedGrades { return false }
        if lhs.methods != rhs.methods { return false }
        if lhs.schedules != rhs.schedules { return false }
        if lhs.hasParseError_p != rhs.hasParseError_p { return false }
        if lhs.isAnnual != rhs.isAnnual { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_RegisteredCourse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RegisteredCourse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "user_id"),
        3: .same(proto: "year"),
        4: .same(proto: "code"),
        5: .same(proto: "name"),
        6: .same(proto: "instructors"),
        7: .same(proto: "credit"),
        8: .same(proto: "methods"),
        9: .same(proto: "schedules"),
        10: .same(proto: "memo"),
        11: .same(proto: "attendance"),
        12: .same(proto: "absence"),
        13: .same(proto: "late"),
        14: .standard(proto: "tag_ids"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._id)
            case 2: try decoder.decodeSingularMessageField(value: &self._userID)
            case 3: try decoder.decodeSingularMessageField(value: &self._year)
            case 4: try decoder.decodeSingularStringField(value: &self._code)
            case 5: try decoder.decodeSingularStringField(value: &self.name)
            case 6: try decoder.decodeSingularStringField(value: &self.instructors)
            case 7: try decoder.decodeSingularStringField(value: &self.credit)
            case 8: try decoder.decodeRepeatedEnumField(value: &self.methods)
            case 9: try decoder.decodeRepeatedMessageField(value: &self.schedules)
            case 10: try decoder.decodeSingularStringField(value: &self.memo)
            case 11: try decoder.decodeSingularInt32Field(value: &self.attendance)
            case 12: try decoder.decodeSingularInt32Field(value: &self.absence)
            case 13: try decoder.decodeSingularInt32Field(value: &self.late)
            case 14: try decoder.decodeRepeatedMessageField(value: &self.tagIds)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._userID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._year {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._code {
            try visitor.visitSingularStringField(value: v, fieldNumber: 4)
        } }()
        if !self.name.isEmpty {
            try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
        }
        if !self.instructors.isEmpty {
            try visitor.visitSingularStringField(value: self.instructors, fieldNumber: 6)
        }
        if !self.credit.isEmpty {
            try visitor.visitSingularStringField(value: self.credit, fieldNumber: 7)
        }
        if !self.methods.isEmpty {
            try visitor.visitPackedEnumField(value: self.methods, fieldNumber: 8)
        }
        if !self.schedules.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.schedules, fieldNumber: 9)
        }
        if !self.memo.isEmpty {
            try visitor.visitSingularStringField(value: self.memo, fieldNumber: 10)
        }
        if self.attendance != 0 {
            try visitor.visitSingularInt32Field(value: self.attendance, fieldNumber: 11)
        }
        if self.absence != 0 {
            try visitor.visitSingularInt32Field(value: self.absence, fieldNumber: 12)
        }
        if self.late != 0 {
            try visitor.visitSingularInt32Field(value: self.late, fieldNumber: 13)
        }
        if !self.tagIds.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.tagIds, fieldNumber: 14)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_RegisteredCourse, rhs: Timetable_V1_RegisteredCourse) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._userID != rhs._userID { return false }
        if lhs._year != rhs._year { return false }
        if lhs._code != rhs._code { return false }
        if lhs.name != rhs.name { return false }
        if lhs.instructors != rhs.instructors { return false }
        if lhs.credit != rhs.credit { return false }
        if lhs.methods != rhs.methods { return false }
        if lhs.schedules != rhs.schedules { return false }
        if lhs.memo != rhs.memo { return false }
        if lhs.attendance != rhs.attendance { return false }
        if lhs.absence != rhs.absence { return false }
        if lhs.late != rhs.late { return false }
        if lhs.tagIds != rhs.tagIds { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Tag"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .standard(proto: "user_id"),
        3: .same(proto: "name"),
        4: .same(proto: "order"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._id)
            case 2: try decoder.decodeSingularMessageField(value: &self._userID)
            case 3: try decoder.decodeSingularStringField(value: &self.name)
            case 4: try decoder.decodeSingularInt32Field(value: &self.order)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._userID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !self.name.isEmpty {
            try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
        }
        if self.order != 0 {
            try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_Tag, rhs: Timetable_V1_Tag) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._userID != rhs._userID { return false }
        if lhs.name != rhs.name { return false }
        if lhs.order != rhs.order { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: timetable/v1/service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public struct Timetable_V1_ListCoursesByCodesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var year: Shared_AcademicYear {
        get { return _year ?? Shared_AcademicYear() }
        set { _year = newValue }
    }

    /// Returns true if `year` has been explicitly set.
    public var hasYear: Bool { return self._year != nil }
    /// Clears the value of `year`. Subsequent reads from it will return its default value.
    public mutating func clearYear() { self._year = nil }

    public var codes: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _year: Shared_AcademicYear? = nil
}

public struct Timetable_V1_ListCoursesByCodesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var courses: [Timetable_V1_Course] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_SearchCoursesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var year: Shared_AcademicYear {
        get { return _year ?? Shared_AcademicYear() }
        set { _year = newValue }
    }

    /// Returns true if `year` has been explicitly set.
    public var hasYear: Bool { return self._year != nil }
    /// Clears the value of `year`. Subsequent reads from it will return its default value.
    public mutating func clearYear() { self._year = nil }

    public var keywords: [String] = []

    public var codePrefixesIncluded: [String] = []

    public var codePrefixesExcluded: [String] = []

    public var schedulesFullyIncluded: [Timetable_V1_Schedule] = []

    public var schedulesPartiallyOverlapped: [Timetable_V1_Schedule] = []

    public var limit: Int32 = 0

    public var offset: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _year: Shared_AcademicYear? = nil
}

public struct Timetable_V1_SearchCoursesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var courses: [Timetable_V1_Course] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_CreateRegisteredCoursesByCodesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var year: Shared_AcademicYear {
        get { return _year ?? Shared_AcademicYear() }
        set { _year = newValue }
    }

    /// Returns true if `year` has been explicitly set.
    public var hasYear: Bool { return self._year != nil }
    /// Clears the value of `year`. Subsequent reads from it will return its default value.
    public mutating func clearYear() { self._year = nil }

    public var codes: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _year: Shared_AcademicYear? = nil
}

public struct Timetable_V1_CreateRegisteredCoursesByCodesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var registeredCourses: [Timetable_V1_RegisteredCourse] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_CreateRegisteredCourseManuallyRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var year: Shared_AcademicYear {
        get { return _year ?? Shared_AcademicYear() }
        set { _year = newValue }
    }

    /// Returns true if `year` has been explicitly set.
    public var hasYear: Bool { return self._year != nil }
    /// Clears the value of `year`. Subsequent reads from it will return its default value.
    public mutating func clearYear() { self._year = nil }

    public var name: String = String()

    public var instructors: String = String()

    public var credit: String = String()

    public var methods: [Timetable_V1_CourseMethod] = []

    public var schedules: [Timetable_V1_Schedule] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _year: Shared_AcademicYear? = nil
}

public struct Timetable_V1_CreateRegisteredCourseManuallyResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var registeredCourse: Timetable_V1_RegisteredCourse {
        get { return _registeredCourse ?? Timetable_V1_RegisteredCourse() }
        set { _registeredCourse = newValue }
    }

    /// Returns true if `registeredCourse` has been explicitly set.
    public var hasRegisteredCourse: Bool { return self._registeredCourse != nil }
    /// Clears the value of `registeredCourse`. Subsequent reads from it will return its default value.
    public mutating func clearRegisteredCourse() { self._registeredCourse = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _registeredCourse: Timetable_V1_RegisteredCourse? = nil
}

public struct Timetable_V1_ListRegisteredCoursesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var year: Shared_AcademicYear {
        get { return _year ?? Shared_AcademicYear() }
        set { _year = newValue }
    }

    /// Returns true if `year` has been explicitly set.
    public var hasYear: Bool { return self._year != nil }
    /// Clears the value of `year`. Subsequent reads from it will return its default value.
    public mutating func clearYear() { self._year = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _year: Shared_AcademicYear? = nil
}

public struct Timetable_V1_ListRegisteredCoursesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var registeredCourses: [Timetable_V1_RegisteredCourse] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_UpdateRegisteredCourseRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Shared_UUID {
        get { return _id ?? Shared_UUID() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool { return self._id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() { self._id = nil }

    public var name: String {
        get { return _name ?? String() }
        set { _name = newValue }
    }

    /// Returns true if `name` has been explicitly set.
    public var hasName: Bool { return self._name != nil }
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating func clearName() { self._name = nil }

    public var instructors: String {
        get { return _instructors ?? String() }
        set { _instructors = newValue }
    }

    /// Returns true if `instructors` has been explicitly set.
    public var hasInstructors: Bool { return self._instructors != nil }
    /// Clears the value of `instructors`. Subsequent reads from it will return its default value.
    public mutating func clearInstructors() { self._instructors = nil }

    public var credit: String {
        get { return _credit ?? String() }
        set { _credit = newValue }
    }

    /// Returns true if `credit` has been explicitly set.
    public var hasCredit: Bool { return self._credit != nil }
    /// Clears the value of `credit`. Subsequent reads from it will return its default value.
    public mutating func clearCredit() { self._credit = nil }

    public var methods: Timetable_V1_CourseMethodList {
        get { return _methods ?? Timetable_V1_CourseMethodList() }
        set { _methods = newValue }
    }

    /// Returns true if `methods` has been explicitly set.
    public var hasMethods: Bool { return self._methods != nil }
    /// Clears the value of `methods`. Subsequent reads from it will return its default value.
    public mutating func clearMethods() { self._methods = nil }

    public var schedules: Timetable_V1_ScheduleList {
        get { return _schedules ?? Timetable_V1_ScheduleList() }
        set { _schedules = newValue }
    }

    /// Returns true if `schedules` has been explicitly set.
    public var hasSchedules: Bool { return self._schedules != nil }
    /// Clears the value of `schedules`. Subsequent reads from it will return its default value.
    public mutating func clearSchedules() { self._schedules = nil }

    public var memo: String {
        get { return _memo ?? String() }
        set { _memo = newValue }
    }

    /// Returns true if `memo` has been explicitly set.
    public var hasMemo: Bool { return self._memo != nil }
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    public mutating func clearMemo() { self._memo = nil }

    public var attendance: Int32 {
        get { return _attendance ?? 0 }
        set { _attendance = newValue }
    }

    /// Returns true if `attendance` has been explicitly set.
    public var hasAttendance: Bool { return self._attendance != nil }
    /// Clears the value of `attendance`. Subsequent reads from it will return its default value.
    public mutating func clearAttendance() { self._attendance = nil }

    public var absence: Int32 {
        get { return _absence ?? 0 }
        set { _absence = newValue }
    }

    /// Returns true if `absence` has been explicitly set.
    public var hasAbsence: Bool { return self._absence != nil }
    /// Clears the value of `absence`. Subsequent reads from it will return its default value.
    public mutating func clearAbsence() { self._absence = nil }

    public var late: Int32 {
        get { return _late ?? 0 }
        set { _late = newValue }
    }

    /// Returns true if `late` has been explicitly set.
    public var hasLate: Bool { return self._late != nil }
    /// Clears the value of `late`. Subsequent reads from it will return its default value.
    public mutating func clearLate() { self._late = nil }

    public var tagIds: Shared_UUIDList {
        get { return _tagIds ?? Shared_UUIDList() }
        set { _tagIds = newValue }
    }

    /// Returns true if `tagIds` has been explicitly set.
    public var hasTagIds: Bool { return self._tagIds != nil }
    /// Clears the value of `tagIds`. Subsequent reads from it will return its default value.
    public mutating func clearTagIds() { self._tagIds = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Shared_UUID? = nil
    fileprivate var _name: String? = nil
    fileprivate var _instructors: String? = nil
    fileprivate var _credit: String? = nil
    fileprivate var _methods: Timetable_V1_CourseMethodList? = nil
    fileprivate var _schedules: Timetable_V1_ScheduleList? = nil
    fileprivate var _memo: String? = nil
    fileprivate var _attendance: Int32? = nil
    fileprivate var _absence: Int32? = nil
    fileprivate var _late: Int32? = nil
    fileprivate var _tagIds: Shared_UUIDList? = nil
}

public struct Timetable_V1_UpdateRegisteredCourseResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var registeredCourse: Timetable_V1_RegisteredCourse {
        get { return _registeredCourse ?? Timetable_V1_RegisteredCourse() }
        set { _registeredCourse = newValue }
    }

    /// Returns true if `registeredCourse` has been explicitly set.
    public var hasRegisteredCourse: Bool { return self._registeredCourse != nil }
    /// Clears the value of `registeredCourse`. Subsequent reads from it will return its default value.
    public mutating func clearRegisteredCourse() { self._registeredCourse = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _registeredCourse: Timetable_V1_RegisteredCourse? = nil
}

public struct Timetable_V1_DeleteRegisteredCourseRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Shared_UUID {
        get { return _id ?? Shared_UUID() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool { return self._id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() { self._id = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Shared_UUID? = nil
}

public struct Timetable_V1_DeleteRegisteredCourseResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_CreateTagRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_CreateTagResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var tag: Timetable_V1_Tag {
        get { return _tag ?? Timetable_V1_Tag() }
        set { _tag = newValue }
    }

    /// Returns true if `tag` has been explicitly set.
    public var hasTag: Bool { return self._tag != nil }
    /// Clears the value of `tag`. Subsequent reads from it will return its default value.
    public mutating func clearTag() { self._tag = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _tag: Timetable_V1_Tag? = nil
}

public struct Timetable_V1_ListTagsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_ListTagsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var tags: [Timetable_V1_Tag] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_UpdateTagRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Shared_UUID {
        get { return _id ?? Shared_UUID() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool { return self._id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() { self._id = nil }

    public var name: String {
        get { return _name ?? String() }
        set { _name = newValue }
    }

    /// Returns true if `name` has been explicitly set.
    public var hasName: Bool { return self._name != nil }
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating func clearName() { self._name = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Shared_UUID? = nil
    fileprivate var _name: String? = nil
}

public struct Timetable_V1_UpdateTagResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var tag: Timetable_V1_Tag {
        get { return _tag ?? Timetable_V1_Tag() }
        set { _tag = newValue }
    }

    /// Returns true if `tag` has been explicitly set.
    public var hasTag: Bool { return self._tag != nil }
    /// Clears the value of `tag`. Subsequent reads from it will return its default value.
    public mutating func clearTag() { self._tag = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _tag: Timetable_V1_Tag? = nil
}

public struct Timetable_V1_DeleteTagRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Shared_UUID {
        get { return _id ?? Shared_UUID() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool { return self._id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() { self._id = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: Shared_UUID? = nil
}

public struct Timetable_V1_DeleteTagResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_RearrangeTagsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Please specify all tag ids that the user have.
    public var ids: [Shared_UUID] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct Timetable_V1_RearrangeTagsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var tags: [Timetable_V1_Tag] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "timetable.v1"

extension Timetable_V1_ListCoursesByCodesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListCoursesByCodesRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "year"),
        2: .same(proto: "codes"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._year)
            case 2: try decoder.decodeRepeatedStringField(value: &self.codes)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._year {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !self.codes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.codes, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_ListCoursesByCodesRequest, rhs: Timetable_V1_ListCoursesByCodesRequest) -> Bool {
        if lhs._year != rhs._year { return false }
        if lhs.codes != rhs.codes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_ListCoursesByCodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListCoursesByCodesResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "courses"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &self.courses)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.courses.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.courses, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_ListCoursesByCodesResponse, rhs: Timetable_V1_ListCoursesByCodesResponse) -> Bool {
        if lhs.courses != rhs.courses { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_SearchCoursesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SearchCoursesRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "year"),
        2: .same(proto: "keywords"),
        3: .standard(proto: "code_prefixes_included"),
        4: .standard(proto: "code_prefixes_excluded"),
        5: .standard(proto: "schedules_fully_included"),
        6: .standard(proto: "schedules_partially_overlapped"),
        7: .same(proto: "limit"),
        8: .same(proto: "offset"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._year)
            case 2: try decoder.decodeRepeatedStringField(value: &self.keywords)
            case 3: try decoder.decodeRepeatedStringField(value: &self.codePrefixesIncluded)
            case 4: try decoder.decodeRepeatedStringField(value: &self.codePrefixesExcluded)
            case 5: try decoder.decodeRepeatedMessageField(value: &self.schedulesFullyIncluded)
            case 6: try decoder.decodeRepeatedMessageField(value: &self.schedulesPartiallyOverlapped)
            case 7: try decoder.decodeSingularInt32Field(value: &self.limit)
            case 8: try decoder.decodeSingularInt32Field(value: &self.offset)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._year {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !self.keywords.isEmpty {
            try visitor.visitRepeatedStringField(value: self.keywords, fieldNumber: 2)
        }
        if !self.codePrefixesIncluded.isEmpty {
            try visitor.visitRepeatedStringField(value: self.codePrefixesIncluded, fieldNumber: 3)
        }
        if !self.codePrefixesExcluded.isEmpty {
            try visitor.visitRepeatedStringField(value: self.codePrefixesExcluded, fieldNumber: 4)
        }
        if !self.schedulesFullyIncluded.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.schedulesFullyIncluded, fieldNumber: 5)
        }
        if !self.schedulesPartiallyOverlapped.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.schedulesPartiallyOverlapped, fieldNumber: 6)
        }
        if self.limit != 0 {
            try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 7)
        }
        if self.offset != 0 {
            try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_SearchCoursesRequest, rhs: Timetable_V1_SearchCoursesRequest) -> Bool {
        if lhs._year != rhs._year { return false }
        if lhs.keywords != rhs.keywords { return false }
        if lhs.codePrefixesIncluded != rhs.codePrefixesIncluded { return false }
        if lhs.codePrefixesExcluded != rhs.codePrefixesExcluded { return false }
        if lhs.schedulesFullyIncluded != rhs.schedulesFullyIncluded { return false }
        if lhs.schedulesPartiallyOverlapped != rhs.schedulesPartiallyOverlapped { return false }
        if lhs.limit != rhs.limit { return false }
        if lhs.offset != rhs.offset { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_SearchCoursesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SearchCoursesResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "courses"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &self.courses)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.courses.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.courses, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_SearchCoursesResponse, rhs: Timetable_V1_SearchCoursesResponse) -> Bool {
        if lhs.courses != rhs.courses { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_CreateRegisteredCoursesByCodesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateRegisteredCoursesByCodesRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "year"),
        2: .same(proto: "codes"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._year)
            case 2: try decoder.decodeRepeatedStringField(value: &self.codes)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._year {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !self.codes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.codes, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_CreateRegisteredCoursesByCodesRequest, rhs: Timetable_V1_CreateRegisteredCoursesByCodesRequest) -> Bool {
        if lhs._year != rhs._year { return false }
        if lhs.codes != rhs.codes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_CreateRegisteredCoursesByCodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateRegisteredCoursesByCodesResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "registered_courses"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &self.registeredCourses)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.registeredCourses.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.registeredCourses, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_CreateRegisteredCoursesByCodesResponse, rhs: Timetable_V1_CreateRegisteredCoursesByCodesResponse) -> Bool {
        if lhs.registeredCourses != rhs.registeredCourses { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_CreateRegisteredCourseManuallyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateRegisteredCourseManuallyRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "year"),
        2: .same(proto: "name"),
        3: .same(proto: "instructors"),
        4: .same(proto: "credit"),
        5: .same(proto: "methods"),
        6: .same(proto: "schedules"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._year)
            case 2: try decoder.decodeSingularStringField(value: &self.name)
            case 3: try decoder.decodeSingularStringField(value: &self.instructors)
            case 4: try decoder.decodeSingularStringField(value: &self.credit)
            case 5: try decoder.decodeRepeatedEnumField(value: &self.methods)
            case 6: try decoder.decodeRepeatedMessageField(value: &self.schedules)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._year {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !self.name.isEmpty {
            try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
        }
        if !self.instructors.isEmpty {
            try visitor.visitSingularStringField(value: self.instructors, fieldNumber: 3)
        }
        if !self.credit.isEmpty {
            try visitor.visitSingularStringField(value: self.credit, fieldNumber: 4)
        }
        if !self.methods.isEmpty {
            try visitor.visitPackedEnumField(value: self.methods, fieldNumber: 5)
        }
        if !self.schedules.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.schedules, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_CreateRegisteredCourseManuallyRequest, rhs: Timetable_V1_CreateRegisteredCourseManuallyRequest) -> Bool {
        if lhs._year != rhs._year { return false }
        if lhs.name != rhs.name { return false }
        if lhs.instructors != rhs.instructors { return false }
        if lhs.credit != rhs.credit { return false }
        if lhs.methods != rhs.methods { return false }
        if lhs.schedules != rhs.schedules { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_CreateRegisteredCourseManuallyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateRegisteredCourseManuallyResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "registered_course"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._registeredCourse)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._registeredCourse {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_CreateRegisteredCourseManuallyResponse, rhs: Timetable_V1_CreateRegisteredCourseManuallyResponse) -> Bool {
        if lhs._registeredCourse != rhs._registeredCourse { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_ListRegisteredCoursesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListRegisteredCoursesRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "year"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._year)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._year {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_ListRegisteredCoursesRequest, rhs: Timetable_V1_ListRegisteredCoursesRequest) -> Bool {
        if lhs._year != rhs._year { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_ListRegisteredCoursesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListRegisteredCoursesResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "registered_courses"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &self.registeredCourses)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.registeredCourses.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.registeredCourses, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_ListRegisteredCoursesResponse, rhs: Timetable_V1_ListRegisteredCoursesResponse) -> Bool {
        if lhs.registeredCourses != rhs.registeredCourses { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_UpdateRegisteredCourseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateRegisteredCourseRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "name"),
        3: .same(proto: "instructors"),
        4: .same(proto: "credit"),
        5: .same(proto: "methods"),
        6: .same(proto: "schedules"),
        7: .same(proto: "memo"),
        8: .same(proto: "attendance"),
        9: .same(proto: "absence"),
        10: .same(proto: "late"),
        11: .standard(proto: "tag_ids"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._id)
            case 2: try decoder.decodeSingularStringField(value: &self._name)
            case 3: try decoder.decodeSingularStringField(value: &self._instructors)
            case 4: try decoder.decodeSingularStringField(value: &self._credit)
            case 5: try decoder.decodeSingularMessageField(value: &self._methods)
            case 6: try decoder.decodeSingularMessageField(value: &self._schedules)
            case 7: try decoder.decodeSingularStringField(value: &self._memo)
            case 8: try decoder.decodeSingularInt32Field(value: &self._attendance)
            case 9: try decoder.decodeSingularInt32Field(value: &self._absence)
            case 10: try decoder.decodeSingularInt32Field(value: &self._late)
            case 11: try decoder.decodeSingularMessageField(value: &self._tagIds)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._name {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._instructors {
            try visitor.visitSingularStringField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._credit {
            try visitor.visitSingularStringField(value: v, fieldNumber: 4)
        } }()
        try { if let v = self._methods {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try { if let v = self._schedules {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        } }()
        try { if let v = self._memo {
            try visitor.visitSingularStringField(value: v, fieldNumber: 7)
        } }()
        try { if let v = self._attendance {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
        } }()
        try { if let v = self._absence {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
        } }()
        try { if let v = self._late {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
        } }()
        try { if let v = self._tagIds {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_UpdateRegisteredCourseRequest, rhs: Timetable_V1_UpdateRegisteredCourseRequest) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._name != rhs._name { return false }
        if lhs._instructors != rhs._instructors { return false }
        if lhs._credit != rhs._credit { return false }
        if lhs._methods != rhs._methods { return false }
        if lhs._schedules != rhs._schedules { return false }
        if lhs._memo != rhs._memo { return false }
        if lhs._attendance != rhs._attendance { return false }
        if lhs._absence != rhs._absence { return false }
        if lhs._late != rhs._late { return false }
        if lhs._tagIds != rhs._tagIds { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_UpdateRegisteredCourseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateRegisteredCourseResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "registered_course"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._registeredCourse)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._registeredCourse {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_UpdateRegisteredCourseResponse, rhs: Timetable_V1_UpdateRegisteredCourseResponse) -> Bool {
        if lhs._registeredCourse != rhs._registeredCourse { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_DeleteRegisteredCourseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteRegisteredCourseRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._id)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_DeleteRegisteredCourseRequest, rhs: Timetable_V1_DeleteRegisteredCourseRequest) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_DeleteRegisteredCourseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteRegisteredCourseResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_DeleteRegisteredCourseResponse, rhs: Timetable_V1_DeleteRegisteredCourseResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_CreateTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateTagRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &self.name)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.name.isEmpty {
            try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_CreateTagRequest, rhs: Timetable_V1_CreateTagRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_CreateTagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateTagResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "tag"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._tag)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._tag {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_CreateTagResponse, rhs: Timetable_V1_CreateTagResponse) -> Bool {
        if lhs._tag != rhs._tag { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_ListTagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListTagsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_ListTagsRequest, rhs: Timetable_V1_ListTagsRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_ListTagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListTagsResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "tags"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &self.tags)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.tags.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_ListTagsResponse, rhs: Timetable_V1_ListTagsResponse) -> Bool {
        if lhs.tags != rhs.tags { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_UpdateTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateTagRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "name"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._id)
            case 2: try decoder.decodeSingularStringField(value: &self._name)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._name {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_UpdateTagRequest, rhs: Timetable_V1_UpdateTagRequest) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._name != rhs._name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_UpdateTagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateTagResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "tag"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._tag)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._tag {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_UpdateTagResponse, rhs: Timetable_V1_UpdateTagResponse) -> Bool {
        if lhs._tag != rhs._tag { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_DeleteTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteTagRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &self._id)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_DeleteTagRequest, rhs: Timetable_V1_DeleteTagRequest) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_DeleteTagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteTagResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_DeleteTagResponse, rhs: Timetable_V1_DeleteTagResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_RearrangeTagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RearrangeTagsRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ids"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &self.ids)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.ids.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_RearrangeTagsRequest, rhs: Timetable_V1_RearrangeTagsRequest) -> Bool {
        if lhs.ids != rhs.ids { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Timetable_V1_RearrangeTagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RearrangeTagsResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "tags"),
    ]

    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &self.tags)
            default: break
            }
        }
    }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.tags.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Timetable_V1_RearrangeTagsResponse, rhs: Timetable_V1_RearrangeTagsResponse) -> Bool {
        if lhs.tags != rhs.tags { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
